"use strict";var _constants=require("../constants");Object.defineProperty(exports,"__esModule",{value:!0}),exports.findNodeByValue=findNodeByValue,exports.flattenTree=flattenTree,exports.hasChildChecked=hasChildChecked,exports.hasParentChecked=hasParentChecked,exports.liftTreeState=liftTreeState,exports.matchAllLeafValue=matchAllLeafValue,exports.reconcile=reconcile,exports.removeAllDescendanceValue=removeAllDescendanceValue,exports.shallowEqualArray=shallowEqualArray,exports.sinkTreeState=sinkTreeState,exports.sortByTree=sortByTree,exports.transformValue=transformValue,require("core-js/modules/es.string.includes.js"),require("core-js/modules/web.dom-collections.iterator.js"),require("core-js/modules/es.array.reduce.js"),require("core-js/modules/es.array.sort.js");function ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function _objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?ownKeys(Object(b),!0).forEach(function(c){_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}// Tile the tree structure, which is convenient to get all NodeItem nodes according to value (string)
// add parent link to parent node
function flattenTree(a){function b(a){let d=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;if(a){const e=[];for(let f=0;f<a.length;f++){const g=a[f],{children:h}=g,i=_objectSpread(_objectSpread({},g),{},{parent:d});c.push(i),e.push(i),h&&b(h,i)}d&&(d.children=e)}}const c=[];return b(a),c}// 是否有子节点（包括自己）被选中
function hasChildChecked(a,b){function c(a){if(!a)return!1;const{value:d,children:e}=a;return!!b.includes(d)||!!e&&e.some(a=>c(a))}return c(a)}// 是否有父节点（包括自己）被选中
function hasParentChecked(a,b){for(let c=a;c;){if(b.includes(c.value))return!0;c=c.parent}return!1}function matchAllLeafValue(a,b){function c(b,e){b&&b.forEach(b=>{const{value:f,children:g}=b;e||a.includes(f)?g?c(g,!0):d.push(f):c(g,e)})}const d=[];return c(b,!1),Array.from(new Set(d))}// delete the value of all descendant nodes, excluding self
// input may be dirty
function removeAllDescendanceValue(a,b){function c(a){a.children&&a.children.forEach(a=>{d.push(a.value),c(a)})}const d=[];return c(a),b.filter(a=>!d.includes(a))}// state improvement
function liftTreeState(a,b){const{value:c}=a,d=b.concat(c);// add the current node value
let e=a;// eslint-disable-next-line no-constant-condition
for(;;){var f,g;// If all child nodes of the parent node have been checked, add the node value and continue to try to improve
if(null!==(f=e)&&void 0!==f&&null!==(g=f.parent)&&void 0!==g&&g.children.every(a=>d.includes(a.value)))d.push(e.parent.value),e=e.parent;else break}// Remove all children and descendants of the last checked parent node value
return removeAllDescendanceValue(e,d)}// 状态下沉
function sinkTreeState(a,b){function c(a){return a?(e.push(a.value),b.includes(a.value)?a:c(a.parent)):null}function d(b){b.children&&b.value!==a.value&&b.children.forEach(b=>{b.value!==a.value&&(e.includes(b.value)?d(b):f.push(b.value))})}const e=[],f=[],g=c(a);if(!g)return b;d(g);// replace the value of the subtree under checkedParent
const h=removeAllDescendanceValue(g,b).filter(a=>a!==g.value);return Array.from(new Set(h.concat(f)))}// checked, unchecked 时重新计算
function reconcile(a,b,c){return b?hasParentChecked(a,c)?c:liftTreeState(a,c):sinkTreeState(a,c)}// Sort by dfs preorder of the tree
function sortByTree(a,b){// sort by tree structure
const c=b.reduce((a,b,c)=>(a[b.value]=c,a),{});return a.sort((d,a)=>c[d]-c[a]||0)}// filter illegal data, sort
function transformValue(a,b){let c=[];if(a.some(a=>a===_constants.All))return[_constants.All];for(let d=0;d<a.length;d++){const e=b.find(b=>b.value===a[d]);e?c=reconcile(e,!0,c):c.push(a[d])}return sortByTree(c,b)}function shallowEqualArray(a,b){if(a===b)return!0;if(!a||!b)return!1;var c=a.length;if(b.length!==c)return!1;for(var d=0;d<c;d++)if(a[d]!==b[d])return!1;return!0}// find tree node by value
function findNodeByValue(a,b){function c(b){if(b)for(let d=0;d<b.length;d++){const e=b[d];if(a===e.value)return e;if(e.children){const a=c(e.children);if(a)return a}}}return c(b)}